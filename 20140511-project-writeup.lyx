#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass paper
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
DNSC 6279 - Data Mining - Project Report
\end_layout

\begin_layout Author
Daniel Chudnov
\end_layout

\begin_layout Date
May 12, 2014
\end_layout

\begin_layout Section
Problem Statement
\end_layout

\begin_layout Standard
Github (github.com) is a popular social network for software developers and
 the code they produce.
 It allows individual programmers and groups or organizations to publish
 and share their code using the Git version control software application,
 and it enables powerful features for sharing changes to code.
 Many of the world's most widely used software products are shared on Github,
 such as the Linux kernel, and even projects that aren't actively developed
 using Github mirror their code to Github for the benefits of visiblity
 and ease of use Github offers, including the Apache web server, the Python
 programming language, the PostgreSQL database, and Git itself.
 By a rough count (using the monotonically-increasing 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 variable present in API calls to list repositories registered in Github,
 more about which below), there have been well over nineteen million software
 project repositories registered in Github since its inception in early
 2008.
 In my own work at GW and within my industry (software development in libraries)
 I and most of my colleagues perform the majority of our work using Github,
 so I have a strong personal interest in its success as a platform and what
 we may learn from it.
\end_layout

\begin_layout Standard
One of the hardest choicest to make as a software developer -- especially
 as one who works with free/libre/open source software often, as I and my
 colleagues do -- is which software projects and products written by other
 people we should use as a basis upon which to build our own software.
 For any common computing problem there are at least three different packages
 available in any programming language of choice, so which is the best to
 use? Which packages work best, and which new initiatives are likely to
 
\begin_inset Quotes eld
\end_inset

get traction
\begin_inset Quotes erd
\end_inset

? There is a natural tension between doing new work in software and building
 that new work upon other, existing, reliable packages, to narrow the scope
 of innovation and to allow for a stable development environment.
 Because of this software developers have a natural tendency to look for
 certain things when evaluating a package: Who is its author? How long has
 it been under development, and how active has its development been lately?
 Does the community use tickets and milestones to plan releases? Have others
 
\begin_inset Quotes eld
\end_inset

forked
\begin_inset Quotes erd
\end_inset

 the package (made their own copy) and submitted their own changes to it?
 No one answer to these questions is a perfect piece of information, rather
 we go on intuition and experience to make these choices.
\end_layout

\begin_layout Standard
The Github API (developer.github.com/v3/) provides an opportunity to examine
 these choices, and to determine whether we can predict the potential success
 of a software project using data rather than simply by intuition.
 For each repository in Github, extensive metadata about that repository
 and its activity is available through a well-documented set of API calls.
 For this project, I collected this metadata for roughly 10,000 repositories
 registered between 2008-2010, and I attempted to build several models that
 might tell us more about what we can determine automatically about any
 repository in Github, based on how the project is managed in Github, the
 programming language choices its authors make, and patterns of recent developme
nt activity for each project.
 Although I do not have a great deal of confidence in these models, the
 process has taught me a lot about the data mining process, especially the
 critical data collection and pre-processing steps, and also about Github
 as a community.
\end_layout

\begin_layout Section
Data Selection
\end_layout

\begin_layout Standard
I used the following calls to Github's API to return data for each repository.
 Note that each URL begins with 
\begin_inset Quotes eld
\end_inset

https://api.github.com
\begin_inset Quotes erd
\end_inset

.
 These API calls are documented extensively on the Github API site.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Path
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/repositories
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A pageable list of repositories, starting from oldest
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/repos/owner/name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Basic metadata (owner, name from previous call)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/repos/owner/name/contributors
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pageable details about all code contributors
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/repos/owner/name/stats/participation
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Counts of commits by owner vs.
 all others, past year
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/repos/owner/name/languages
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Relative size of code by programming language
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/repos/owner/name/stats/code_frequency
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Counts of lines added/removed weekly, past year
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
These calls generated a lot of raw data for each repository which I then
 processed further, as described in Section 3 below.
 For each repository, basic metadata of value for this project includes:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Field
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
id
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unique identifier
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
owner
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
repository owning user
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
string
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
repository name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
string
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
created_at
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
date of repository creation
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
date
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pushed_at
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
date of last 
\begin_inset Quotes eld
\end_inset

pushed
\begin_inset Quotes erd
\end_inset

 commit (change)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
date
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fork
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
whether this is a 
\begin_inset Quotes eld
\end_inset

fork
\begin_inset Quotes erd
\end_inset

 or copy of another repository
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
boolean
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
forks_count
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
number of forks of this repository
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
has_wiki
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
whether the project uses Github's wiki pages
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
boolean
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
has_issues
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
whether the project uses Github's issue tracking
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
boolean
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
has_downloads
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
whether the project has downloadable package builds
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
boolean
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
parent_id
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
id of project from which this project was forked, if applicable
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
source_id
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
id of original project from which this and parents were forked
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
size
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
size of the repository, in source lines of code
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
open_issues_count
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
number of currently-open issues in Github's issue tracker
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
stargazers_count
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
# users who have 
\begin_inset Quotes eld
\end_inset

starred
\begin_inset Quotes erd
\end_inset

 (or favorited) this repository
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
subscribers_count
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
# users who subscribe to update notifications
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
network_count
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
number of all forks in network of source repository
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
For this project, I used 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 as an identifier variable, 
\begin_inset Quotes eld
\end_inset

stargazers_count
\begin_inset Quotes erd
\end_inset

 as the target variable, and rejected 
\begin_inset Quotes eld
\end_inset

owner
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 although I carried them through into SAS as useful metadata to check values
 against (we can easily construct a Github URL to a repository if we have
 its owner and name).
\end_layout

\begin_layout Standard
Further details about processed variables are specified in the next section.
\end_layout

\begin_layout Standard
Before continuing, however, a few details about the process of fetching
 data from the API are worth noting.
 Collecting the data from Github proved to be more of a challenge than I
 expected for several reasons:
\end_layout

\begin_layout Itemize
Github limits API calls to 5000/hour, so at the rate of six calls per repository
, it took several overnight runs to collect full data for over 10,000 repositori
es (and re-runs after adjusting the code several times).
\end_layout

\begin_layout Itemize
The fetch script I wrote honors this limit by attempting to wait between
 calls according to the amount of time remaining before the wait limit is
 reset by the API, but I found that this reset time was sliding backwards,
 causing my code to issue calls after a longer delay than necessary.
 After testing this very carefully I wrote to Github staff about it, and
 reported it as a bug with details about my queries.
 They acknowledged it was a bug in their system and thanked me for the report,
 but as far as I know the problem has not yet been fixed.
 I estimate this slowed down my data collection by 30-40%.
\end_layout

\begin_layout Itemize
Some of the API calls (specifically the ones that include '/stats' in the
 URL pattern) are documented as 
\begin_inset Quotes eld
\end_inset

slow
\begin_inset Quotes erd
\end_inset

 on the API side as they calculate summary statistics.
 These calls might result in an HTTP response code 202 Accepted (rather
 than 200 OK) which indicates that the request has been acknowledged but
 the response is not yet ready.
 To accomodate this possibility, which I saw regularly as my fetch script
 executed, I implemented a simple linear backoff strategy to enable subsequent
 calls with an increasing delay between each call.
 This strategy worked, but it also slowed down the data fetching process.
\end_layout

\begin_layout Itemize
Some registered repositories have no meaningful data within them; I chose
 to ignore these, and did not include them in the sample.
\end_layout

\begin_layout Itemize
Some API calls (e.g.
 /stats/contributors) require paging to fetch all results; I used /contributors
 instead to save time, but only after first fetching the more complete details,
 which did not prove interesting after all.
\end_layout

\begin_layout Itemize
Sometimes my script simply failed (due to bad logic or improper error handling
 in my code, failed network connection, etc.).
 At first, I had to restart it over from scratch, but after losing data
 a few times I wrote an 
\begin_inset Quotes eld
\end_inset

append
\begin_inset Quotes erd
\end_inset

 feature that attempts to discover where the process last left off by checking
 the id of the last repository in the most recently saved file (the fetch
 scripts saves data in chunks of 100 repositories per file).
\end_layout

\begin_layout Itemize
After working with the results of metadata about several thousand repositories,
 I noticed an obvious trend I should have considered sooner.
 The API call to list all the repositories in Github started back at the
 beginning of Github, and proceeded chronological order.
 Because of this, I was only retrieving data about the very oldest data
 in Github.
 This seemed like a strong bias to use as the community of users for Github
 started small, like for any social network, and grew first from a set of
 users who had particular interests in the same languages and tools the
 Github developers themselves used.
 Indeed the most active early users were the founders of Github themselves,
 and some of the earliest repositories were Ruby-based web applications
 (Github is a Ruby language application) and Ruby-based libraries for working
 with Git repositories.
 Rather than proceed with this bias, I added a 
\begin_inset Quotes eld
\end_inset

striping
\begin_inset Quotes erd
\end_inset

 function to the fetch script to jump ahead in time between calls.
 With the response to the query returning 100 repositories, I modified the
 next call to the API to jump ahead 9900 repositories, thus taking a sample
 of 100 out of each 10,000 in chronological time, or 1% of repositories
 overall.
 Without this change, my sample set would have only contained the oldest
 repositories from the first few months of Github's existence; instead,
 it includes a sampling of repositories from the first three years.
 This still exhibits a bias of sorts as Github's largest growth has come
 in the past 2-3 years, but this still seemed to be a good enough sample
 for this project.
 Perhaps I will follow up with exploring a larger sample including more
 recent repositories in the future.
\end_layout

\begin_layout Standard
This set of issues led to a longer period of iteration over the data fetching
 process, delaying the processing and modeling steps.
 It reinforced a key lesson, that there is no such thing as 
\begin_inset Quotes eld
\end_inset

clean data
\begin_inset Quotes erd
\end_inset

, even if it's coming from a 
\begin_inset Quotes eld
\end_inset

clean API
\begin_inset Quotes erd
\end_inset

.
 Every API has its own quirks, and possibly flaws, and it will always take
 time to account for and adjust to these issues.
\end_layout

\begin_layout Section
Data Pre-Processing
\end_layout

\begin_layout Standard
What operations did you perform on your data to organize it in a form suitable
 for Enterprise Miner.
 Specify any queries, joins, transformations, how you treat missing values
 etc.
\end_layout

\begin_layout Standard
I collected the data from the Github API into a set of JSON files, 100 records
 per file, for a total of n=10,096 repositories.
 For each repository record, I started with the basic JSON-based response
 to the basic metadata request for each repository and added results from
 the additional calls to the in-memory dictionary for each respository before
 writing each to local disk.
 JSON is an excellent format for this kind of work; it has all the hierarchical
 expressiveness of XML but very little overhead, and it takes exactly one
 line to either read it in or write it out from most languages.
\end_layout

\begin_layout Standard
The overall set of data I chose included a wide variety of potential values.
 It seemed best to explore it some and determine how best to pre-process
 one or more files for import into SAS prior to model building.
 Here are some of the basic impressions the data gave at first glance.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/hist-log-stargazers.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
Starting with the dependent/target variable 
\begin_inset Quotes eld
\end_inset

stargazers_count
\begin_inset Quotes erd
\end_inset

, we see that it has a lognormal distribution evidenced by the histogram
 of the log of this value.
 A small proportion of repositories among the over ten thousand I collected
 ever 
\begin_inset Quotes eld
\end_inset

caught on
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/boolean-has-percentages.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
I suspected that projects that made use of Github's issue tracking feature
 might be more popular because this indicates that the community of developers
 is actively working on the code and soliciting feedback.
 Similarly, but to a lesser extent, I suspected that use of other Github
 features such as their 
\begin_inset Quotes eld
\end_inset

file downloads
\begin_inset Quotes erd
\end_inset

 feature and project wiki pages might also indicate project health.
 The numbers for Downloads and Wiki seem unusually high to me, though, and
 although I've verified that this is what the data I fetched indicates,
 this does not seem to correspond to what I've seen in project sites, in
 particular it seems like far fewer than 90% of projects use the downloads
 feature, but this indicates the percentage is higher than 90%.
 Perhaps these values are not trustworthy.
 The lower number for Issues is perhaps more likely to be accurate, and
 the final bar for Fork, indicating that roughly 30% of repositories are
 forks of other repositories, seems plausible enough, although I am unexcited
 about its potential predictive value.
\end_layout

\begin_layout Standard
Another exploratory chart indicates a strong relationship between forks
 and stargazers:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/pairs-counts.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
Here we can see that there is indeed a strong correlation between the number
 of stargazers and the number of forks of a project.
 This makes intuitive sense; more popular projects seem more likely to find
 other users working with the code, offering up changes, etc.
\end_layout

\begin_layout Standard
At this point it seemed clear that there might not be any groundbreaking
 paradigm to discover here; a log/power tail of projects are popular, popular
 projects get forked a lot, and some of the data from the API might not
 be 100% reliable (based on the percentages of repositories that use downloads
 and wikis).
 It seemed like a good idea to start to derive new attributes from the existing
 data.
\end_layout

\begin_layout Standard
I decided to break the data down along three lines: basic attributes, code
 activity, and languages.
 The basic attributes are those already defined and listed in the previous
 section.
 To this I added the following set of computed values based on activity
 on the repository:
\end_layout

\begin_layout Standard
'star10', 'lang0_prop', 'lang0', 'lang1', 'lang2',
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Field
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
num_contributors
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
count of distinct users contributing code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
num_weeks
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
weeks since project inception
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
num_weeks_since_change
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
weeks since last commit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lines_added
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
total lines added, past year
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lines_added_per_week
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
avg lines added/week, past year
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lines_subtracted
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
total lines subtracted, past year
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lines_subtracted_per_week
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
avg lines subtracted/week, past year
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
all_commits
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
total count of commits
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
owner_commits
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
commits by owner, past year
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
owner_commits_percentage
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
percent of commits by owner, past year
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mean_commits_per_week
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mean commits/week, past year
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
std_commits_per_week
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
standard dev.
 of commits/week, past year
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
These values were readily obtained and computed from the API data provided,
 implemented in the script 
\begin_inset Quotes eld
\end_inset

process.py
\begin_inset Quotes erd
\end_inset

 (see Appendix).
\end_layout

\begin_layout Standard
As an example of these attributes, below is a chart of owner_commits_percentage,
 indicating how many changes to each repository in the past year had been
 commited specifically by the repository owner themself:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/log-owner-commits-freq.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
The vast majority of projects active in the past year had a majority of
 its commits in the past year created by the repository owner (the two bins
 at the far right with log(owner_commits_percentage > four).
 This indicates that a very small minority of projects have a plurality
 of active committers.
\end_layout

\begin_layout Standard
The last area of repository composition I reviewed was the choice of languages
 used in each project.
 I was interested to see if there was any pattern present across several
 years of Github data toward a preference for particular languages, or whether
 these matched language popularity in the wider community.
 Summarizing the languages used in repositories by the top two per each
 (more than one kind of language can be used in a single project, and often
 is) revealed the following basic data:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/lang0-count.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
Note that Ruby is the most popular primary language, followed by JavaScript,
 Python, Java, PHP, Perl, and C.
 This is not a surprising list when compared to industry measures of the
 same information (for example, see http://www.tiobe.com/index.php/tiobe_index)
 and accounting for the early prevalence of Ruby code in Github's early
 days.
\end_layout

\begin_layout Standard
The most-used secondary languages are slightly more interesting:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/lang1-count.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
In this list the most popular secondary languages in projects was JavaScript,
 by far, followed by Shell, Ruby, C, Python, and C++.
 This makes an intuitive sense as many projects in Github are web and mobile
 applications, and many of these applications use at least some JavaScript,
 whether the larger application itself is written in Ruby, Python, PHP,
 or any other language.
 Shell is a common choice for tool scripts around the main code of a project,
 with Unix commands written in Shell to automate tasks related to application
 configuration, data management, backups, and other maintenance tasks.
 
\end_layout

\begin_layout Standard
One final attribute I computed was 
\begin_inset Quotes eld
\end_inset

star10
\begin_inset Quotes erd
\end_inset

, a binary classification of whether a repository had at least ten stargazers.
 This proved to be useful in generating stratified samples as well as being
 a target variable for model generation, as described in the next section.
\end_layout

\begin_layout Section
Mining Technique Selection
\end_layout

\begin_layout Standard
I chose to work with a Regression, Neural Network, and a Classification
 Tree for this model, as each can be used to create predictive models.
 At first I worked with one combined dataset and used stargazers_count as
 the target variable.
 This resulted in unexciting models that did not reveal much, largely due
 to the log distribution of popularity present in stargazers_count, as shown
 above in the histogram of log(stargazers_count).
\end_layout

\begin_layout Standard
I consulted with Professor Prasad who encouraged me to take a stratified
 sample to capture the 
\begin_inset Quotes eld
\end_inset

rare event
\begin_inset Quotes erd
\end_inset

 of popularity according to stargazers_count.
 I added a Sampling node in SAS and found that it was easiest to generate
 an additional binary attribute 
\begin_inset Quotes eld
\end_inset

star10
\begin_inset Quotes erd
\end_inset

, based on whether a repository had at least 10 stargazers, to use as the
 stratification attribute.
 I created a 2000-item sample using a 50/50 equal sized stratification in
 slotted that between the Data Source and Partition nodes, using an 80%/20%
 training/validation split.
 I then fed that to one each of Tree, Neural Network, and Regression models,
 finally drawing each of those into an Assessment node.
 The diagram in Enterprise Miner is the following:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/miner-diagram.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
This represents the final model I will describe in detail now.
 One quick note, however: before combining all the data into one data source,
 I attempted to separate out the three categories of attributes mentioned
 above into their own datasources for basic metadata, project activity,
 and language choices, running the three models paradigms separately on
 each.
 This did not prove fruitful, save for one mildly interesting finding.
 Upon running the neural network on language choice data, it drew out 
\begin_inset Quotes eld
\end_inset

lang1 = JavaScript
\begin_inset Quotes erd
\end_inset

 as a modest predictor of project popularity.
 As noted in the previous section, JavaScript is a prevalent secondary language
 in repositories of many languages, in particular for web and mobile application
s.
 This is not particularly meaningful in the large picture beyond keeping
 in mind that 
\begin_inset Quotes eld
\end_inset

web and mobile applications are popular
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
For all of these models, I began using the 
\begin_inset Quotes eld
\end_inset

stargazers_count
\begin_inset Quotes erd
\end_inset

, an interval attribute, as the target/dependent variable.
 This provide largely difficult to predict well, and none of the models
 were able to come close to a reliable prediction.
 Having derived the new attribute 
\begin_inset Quotes eld
\end_inset

star10
\begin_inset Quotes erd
\end_inset

, a binary classification of whether a repository had at least 10 stargazers,
 to use as a parameter to stratify the sample upon, I tried using star10
 as the target instead of stargazers_count, thinking it might simplify the
 problem somewhat.
 After all, whether a project has 12 or 22 stargazers or whether it has
 500 or 600 doesn't seem terribly important; that it has at least 10 indicates
 some basic level of user interest.
 This proved to be an improvement, as the models all generated somewhat
 better results, if not still overwhelmingly so.
\end_layout

\begin_layout Standard
In all of the following discussion, 
\begin_inset Quotes eld
\end_inset

star10
\begin_inset Quotes erd
\end_inset

 is the target variable.
\end_layout

\begin_layout Section
Data Mining Results
\end_layout

\begin_layout Subsection
Classification Tree
\end_layout

\begin_layout Standard
For the Tree model, I used the Gini reduction splitting criterion and allowed
 SAS to select the model assessment measure by setting it to 
\begin_inset Quotes eld
\end_inset

automatic
\begin_inset Quotes erd
\end_inset

, and left other settings to their defaults.
 It produced a tree that focused primarily on the forks_count attribute,
 noted above as a value apparently linearly correlated with project popularity.
 Below is the tree:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/tree-gini-tree.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
This tree follows simple rules: if there are more than two forks, the project
 is typically at least modestly successful; if there are less than two,
 it probably isn't.
 At both of these ends of the spectrum, the validation data results are
 quite close to the training results.
 In the case of zero or one fork, the model correctly predicted roughly
 1.9% of items as 
\begin_inset Quotes eld
\end_inset

popular
\begin_inset Quotes erd
\end_inset

; for 3-6 forks, the validation rate of 60.7% is close to the training rate
 of 57.8%, and for more than seven forks, from 95.6% (training) to 83.6% (validatio
n) isn't terrible.
 In between these values, particularly for repositories with exactly two
 forks, the validation results are poor.
 The lowest-level split on 
\begin_inset Quotes eld
\end_inset

lang0
\begin_inset Quotes erd
\end_inset

 does not add a lot to the picture.
\end_layout

\begin_layout Standard
The misclassification rates per number of leaves shows a classic set of
 rate curves, with the U-shape of the validation results looking strong.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/tree-gini-chart.png
	scale 80

\end_inset


\end_layout

\begin_layout Standard
This reinforces what we learned about the interpretability of a simple classific
ation tree.
 The splits on forks_count are intuitive and match my expectations as noted
 above.
 Anyone looking at the model can quickly understand that either a low or
 modestly high forks_count on a repository is a good indicator of what to
 expect.
 Ultimately, the takeaway lesson that if you see that at least three different
 people have forked a repository, it probably has at least ten people watching
 it, and is thus 
\begin_inset Quotes eld
\end_inset

popular
\begin_inset Quotes erd
\end_inset

 in some sense, is a decent rule of thumb that is easy to remember.
 The corollary that a project with only zero or one fork is unlikely to
 be successful yet is also intuitive and easy to remember.
\end_layout

\begin_layout Standard
One final observation: the SAS tree model only found a handful of attributes
 even worth considering beyond forks_count and lang0, as indicated in this
 table:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/tree-importance.png

\end_inset


\end_layout

\begin_layout Standard
Among these attributes, only lang0 from among all the language-related attribute
s, and only pushed_at from among the attributes indicating project activity,
 were deemed at all important.
 Even these were found to be of very low importance, on a par with has_wiki
 (discounted due to perceived unreliability in discussion above) and created_at,
 which might bring a component of bias for the older and oldest projects,
 which have simply had more time to be 
\begin_inset Quotes eld
\end_inset

starred
\begin_inset Quotes erd
\end_inset

, especially in the early days when very few repositories had even been
 registered yet.
\end_layout

\begin_layout Subsection
Neural Network
\end_layout

\begin_layout Standard
For the neural network I used a Multilayer Perceptron with misclassification
 rate as the model selection criteria.
 Knowing that a neural network is at the opposite end of the interpretability
 spectrum, let's start with the average error chart:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/network-chart.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
The model performs fairly well after a few iterations but plateaus after
 around 10 and then degrades as we might expect after 30 or so iterations.
 A look at the cumulative lift chart reveals some improvements:
\end_layout

\begin_layout Standard
Here are the fit statistics for the neural network:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/network-fit-stats.png
	scale 80

\end_inset


\end_layout

\begin_layout Standard
We see that the RMSE increases from 0.264 (training) to 0.27 (validation),
 a modest change that indicates that the model might do a decent job with
 predicting.
 The misclassification rate goes from 0.072 (training) to 0.074 (validation),
 also a modest change.
\end_layout

\begin_layout Subsection
Regression
\end_layout

\begin_layout Standard
The regression model zeroed in on forks_count as well, and also pulled in
 
\begin_inset Quotes eld
\end_inset

created_at
\begin_inset Quotes erd
\end_inset

 with a very low weight, which might just be an indication of popularity
 bias toward older projects in the sample, as noted above.
 Otherwise it is not an overwhelmingly compelling model.
 Here are the basic parameter estimates:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/regression-estimates.png
	scale 80

\end_inset

			
\end_layout

\begin_layout Standard
The performance of the regression model reveals a little more:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/regression-fit-stats.png
	scale 80

\end_inset


\end_layout

\begin_layout Standard
Here we see a RMSE of 0.192 in training and 0.21 in validation, indicating
 the model might be performing consistently.
 The misclassification rate increases slightly from 0.046 in training to
 0.054 in validation as well.
\end_layout

\begin_layout Subsection
Comparison
\end_layout

\begin_layout Standard
A look at the combined lift charts reveals no clear winner but a definite
 loser: the regression and tree models work pretty well, but the network
 does not perform as well.
 Here is the combined chart of cumulative lift:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/combined-lift-cumulative.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
Here we see that the tree model performs best, with a lift close to 8 in
 the first decile; the regression model performs nearly as well, still above
 7, and the neural network model offers up a modest improvement at a lift
 of just under 4.
 At the second decile and beyond the regression model appears to outperform
 the tree model slightly.
 A closer look at the noncumulative lift is below:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/combined-lift-noncumulative.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
In this chart the slightly higher slope of the regression model to a positive
 lift at the 20% decile is evident over the more quickly degrading lift
 of the tree model, but they are both offer only marginal results beyond
 the 10% decile.
 An interesting hiccup is the gentle spike at 90% for the neural network;
 perhaps it has some capacity to correctly determine low-end 
\begin_inset Quotes eld
\end_inset

not popular
\begin_inset Quotes erd
\end_inset

 classifications, even if this is not useful.
\end_layout

\begin_layout Standard
We can compare the tree and network models another way, using their misclassific
ation rates:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /Users/dchud/Documents/Box Sync/2013-mbsa/2014s-data-mining/project/writeup-screenshots/combined-misclassification.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
In this table we see that the Root ASE of the tree model degrades a bit
 from training to validation but remains better than the network model at
 0.204.
 The network model comes out at 0.27, degrading less than the tree model
 in validation but offering slightly worse performance.
 This pattern is duplicated in the misclassification rates, with the tree
 model dropping from 0.035 in training to 0.048 in validation, still better
 than the network model, which drops a touch from 0.072 in training to 0.074
 in validation.
\end_layout

\begin_layout Standard
Assembling the misclassification rates from the various two-way charts above,
 we see:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Model
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Misclassification Rate (training)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Misclassification Rate (validation)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tree
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.035
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.048
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Neural Network
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.072
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.074
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Regression
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.046
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.054
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
According to this measure, the tree model outperforms both of the other
 models in both training and in validation.
\end_layout

\begin_layout Subsection
Conclusion
\end_layout

\begin_layout Standard
This project has taught me a great deal if the results are not particularly
 compelling.
 Each of the models zeroes in on forks_count as the key predictor of project
 popularity, and this makes good intuitive sense.
 It is not groundbreaking in any way, except perhaps in what it didn't find:
 there does not seem to be strong predictive value in the main languages
 a project uses or in the recent history of a project's commit activity,
 at least not present in the combination of attributes I used to train the
 models described here.
\end_layout

\begin_layout Standard
The process of collecting data was incredibly valuable to me as a lesson
 in suitability of any data to a particular task.
 I has assumed that collecting data from Github's well-documented API would
 be simple, and that the data would be 
\begin_inset Quotes eld
\end_inset

clean
\begin_inset Quotes erd
\end_inset

, but I spent many weeks iterating over the process and reconsidering the
 measures I was computing.
 I even found a bug in Github's API! All told, however, if I had allowed
 myself more time to work with the data itself I would likely have found
 more attributes to derive for consideration in these models.
\end_layout

\begin_layout Standard
There are many likely flaws in my results, beyond my nascent and weak skills
 in data mining.
 The collected data only comprises records from the first three years of
 github; in the three years since its popularity has grown immensely and
 the variety of projects registered with Github repositories has grown enormousl
y.
 If I were to repeat this study the first step I would take would be to
 repeat the data gathering process to include a wider 
\begin_inset Quotes eld
\end_inset

stripe
\begin_inset Quotes erd
\end_inset

 of data from the entire lifetime of Github.
 A second step I would take would be to more closely examine the attributes
 I derived surrounding the activity around a project.
 I am certain I left out a number of important considerations.
\end_layout

\begin_layout Standard
Two deeper avenues for exploring this data exist as well and I pursued neither.
 First, as suggested by Professor Prasad during my project talk in class,
 the data I collected gives no indication of when users 
\begin_inset Quotes eld
\end_inset

starred
\begin_inset Quotes erd
\end_inset

 the repositories; it just includes the current count of stargazers.
 It would be interesting to track this number over time for a number of
 repositories and compare growth rates, looking for correlations between
 activity and attention/popularity.
 Finally, I would like to consider the code inside each repository.
 Can we glean anything from the actual code used to write applications,
 beyond programming language choices? For example, in Python many projects
 use built-in Python libraries and common third-party support libraries
 for frequently-needed tasks.
 Might there be a correspondence between the use of certain support project
 dependencies and their popularity, especially over time? It would be fascinatin
g to build a dashboard to indicate which support libraries are 
\begin_inset Quotes eld
\end_inset

gaining traction
\begin_inset Quotes erd
\end_inset

 in each of the different programming language communities and in each of
 the respective application sectors.
 This, however, would require a lot more data and a lot more time.
\end_layout

\begin_layout Section
Appendix
\end_layout

\begin_layout Standard
All code from this project and the derived dataset used to train the three
 models is available in a Github repository at https://github.com/dchud/substar.
 In particular, the following scripts handle the tasks described:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Script
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Task
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
github.com/dchud/substar/blob/master/fetch.py
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fetch all data about repositories
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
github.com/dchud/substar/blob/master/process.py
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Process collected data into CSV file
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
github.com/dchud/substar/blob/master/combined-10000.txt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Extracted dataset, n=10,067
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The code for fetch.py (on which I spent the bulk of my time on this project)
 follows:
\end_layout

\begin_layout Standard

\size small
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=Python,numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\size small
#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
"""
\end_layout

\begin_layout Plain Layout

\size small
Load up data about a number of repositories from github using their
\end_layout

\begin_layout Plain Layout

\size small
API.
  Report on results.
\end_layout

\begin_layout Plain Layout

\size small
"""
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
import argparse
\end_layout

\begin_layout Plain Layout

\size small
import glob
\end_layout

\begin_layout Plain Layout

\size small
import json
\end_layout

\begin_layout Plain Layout

\size small
import logging
\end_layout

\begin_layout Plain Layout

\size small
import logging.config
\end_layout

\begin_layout Plain Layout

\size small
from math import ceil
\end_layout

\begin_layout Plain Layout

\size small
import os
\end_layout

\begin_layout Plain Layout

\size small
import re
\end_layout

\begin_layout Plain Layout

\size small
import time
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
import requests
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
from settings import *
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
logging.config.fileConfig('logging.conf')
\end_layout

\begin_layout Plain Layout

\size small
logger = logging.getLogger('fetch')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
HEADERS = {'Authorization': 'token %s' % TOKEN}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
def wait_buffer(req):
\end_layout

\begin_layout Plain Layout

\size small
    """by default, wait this long between requests to follow github's
\end_layout

\begin_layout Plain Layout

\size small
    rate limits."""
\end_layout

\begin_layout Plain Layout

\size small
    reset_seconds = int(req.headers['x-ratelimit-reset']) - ceil(time.time())
\end_layout

\begin_layout Plain Layout

\size small
    remaining = float(req_full_data.headers['x-ratelimit-remaining'])
\end_layout

\begin_layout Plain Layout

\size small
    # pad it a little, just to have a friendly cushion
\end_layout

\begin_layout Plain Layout

\size small
    buffer = 1.1 * reset_seconds / remaining
\end_layout

\begin_layout Plain Layout

\size small
    # whenever the timer gets down close to a reset, add extra cushion
\end_layout

\begin_layout Plain Layout

\size small
    # note also, buffer should never be negative
\end_layout

\begin_layout Plain Layout

\size small
    if buffer < 0.1:
\end_layout

\begin_layout Plain Layout

\size small
        buffer = 0.5
\end_layout

\begin_layout Plain Layout

\size small
    logger.debug('wait: %s' % buffer)
\end_layout

\begin_layout Plain Layout

\size small
    time.sleep(buffer)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
def repo_api_request(owner, name, func, count=0):
\end_layout

\begin_layout Plain Layout

\size small
    """
\end_layout

\begin_layout Plain Layout

\size small
    Retry-able api requests; handle 202 responses with 1+-second delay
\end_layout

\begin_layout Plain Layout

\size small
    retries up to MAX_RETRIES times with linear backoff.
  Ignore rate 
\end_layout

\begin_layout Plain Layout

\size small
    limit; 1+ seconds should always be longer than wait_buffer().
\end_layout

\begin_layout Plain Layout

\size small
    """
\end_layout

\begin_layout Plain Layout

\size small
    logger.debug('func: %s' % func)
\end_layout

\begin_layout Plain Layout

\size small
    r = requests.get('https://api.github.com/repos/%s/%s/%s' % (owner,
\end_layout

\begin_layout Plain Layout

\size small
        name, func), headers=HEADERS)
\end_layout

\begin_layout Plain Layout

\size small
    wait_buffer(r)
\end_layout

\begin_layout Plain Layout

\size small
    if r.status_code == 200:
\end_layout

\begin_layout Plain Layout

\size small
        return r.json()
\end_layout

\begin_layout Plain Layout

\size small
    elif r.status_code == 202:
\end_layout

\begin_layout Plain Layout

\size small
        count += 1
\end_layout

\begin_layout Plain Layout

\size small
        logger.debug('202 Accepted (count %s)' % count)
\end_layout

\begin_layout Plain Layout

\size small
        # linear backoff: always wait at least one extra second per retry
\end_layout

\begin_layout Plain Layout

\size small
        time.sleep(1 * count)
\end_layout

\begin_layout Plain Layout

\size small
        if count <= MAX_RETRIES:
\end_layout

\begin_layout Plain Layout

\size small
            return repo_api_request(owner, name, func, count=count)
\end_layout

\begin_layout Plain Layout

\size small
    logging.error(r)
\end_layout

\begin_layout Plain Layout

\size small
    return None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
def save_recs(recs, count):
\end_layout

\begin_layout Plain Layout

\size small
    # write out the file to disk as an indented json file
\end_layout

\begin_layout Plain Layout

\size small
    filename = 'data/recs-%s.json' % count
\end_layout

\begin_layout Plain Layout

\size small
    fp = open(filename, 'wb')
\end_layout

\begin_layout Plain Layout

\size small
    json.dump(recs, fp, indent=2)
\end_layout

\begin_layout Plain Layout

\size small
    fp.close()
\end_layout

\begin_layout Plain Layout

\size small
    logger.debug('SAVED: %s' % filename)
\end_layout

\begin_layout Plain Layout

\size small
    return filename
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
def next_url(url):
\end_layout

\begin_layout Plain Layout

\size small
    # bump the sinceid 9900 to cycle through all repos over time
\end_layout

\begin_layout Plain Layout

\size small
    # from oldest to most recent
\end_layout

\begin_layout Plain Layout

\size small
    base, equalsign, sinceid = url.partition('=') 
\end_layout

\begin_layout Plain Layout

\size small
    bumped_sinceid = int(sinceid) + 9900
\end_layout

\begin_layout Plain Layout

\size small
    return '%s=%s' % (base, bumped_sinceid)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
if __name__ == '__main__':
\end_layout

\begin_layout Plain Layout

\size small
    parser = argparse.ArgumentParser(description='fetch github repo data')
\end_layout

\begin_layout Plain Layout

\size small
    parser.add_argument('-a', '--append', action='store_true',
\end_layout

\begin_layout Plain Layout

\size small
            default=False, help='pick up where we left off')
\end_layout

\begin_layout Plain Layout

\size small
    args = parser.parse_args()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
    if args.append:
\end_layout

\begin_layout Plain Layout

\size small
        logger.debug('appending')
\end_layout

\begin_layout Plain Layout

\size small
        files = glob.glob('data/*')
\end_layout

\begin_layout Plain Layout

\size small
        oldest_file = max(files, key=os.path.getctime)
\end_layout

\begin_layout Plain Layout

\size small
        logger.debug('oldest_file: %s' % oldest_file)
\end_layout

\begin_layout Plain Layout

\size small
        old_data = json.load(open(oldest_file))
\end_layout

\begin_layout Plain Layout

\size small
        oldest_rec_id = int(old_data[-1]['id'])
\end_layout

\begin_layout Plain Layout

\size small
        logger.debug('oldest_rec_id: %s' % oldest_rec_id)
\end_layout

\begin_layout Plain Layout

\size small
        bumped_rec_id = oldest_rec_id + 9900
\end_layout

\begin_layout Plain Layout

\size small
        req_repos = requests.get(
\end_layout

\begin_layout Plain Layout

\size small
                'https://api.github.com/repositories?since=%s' % bumped_rec_id)
\end_layout

\begin_layout Plain Layout

\size small
        oldest_filename = oldest_file.split('/')[-1]
\end_layout

\begin_layout Plain Layout

\size small
        oldest_count_id = re.findall(r'
\backslash
d+', oldest_filename)[-1]
\end_layout

\begin_layout Plain Layout

\size small
        count = int(oldest_count_id)
\end_layout

\begin_layout Plain Layout

\size small
    else:
\end_layout

\begin_layout Plain Layout

\size small
        # get a list of repos, starting from 0
\end_layout

\begin_layout Plain Layout

\size small
        req_repos = requests.get('https://api.github.com/repositories',
\end_layout

\begin_layout Plain Layout

\size small
            headers=HEADERS)
\end_layout

\begin_layout Plain Layout

\size small
        count = 1
\end_layout

\begin_layout Plain Layout

\size small
    recs = []
\end_layout

\begin_layout Plain Layout

\size small
    next_repos_url = next_url(req_repos.links['next']['url'])
\end_layout

\begin_layout Plain Layout

\size small
    repos = req_repos.json()
\end_layout

\begin_layout Plain Layout

\size small
    while count <= FETCH_LIMIT:
\end_layout

\begin_layout Plain Layout

\size small
        logger.debug('count: %s' % count)
\end_layout

\begin_layout Plain Layout

\size small
        for repo in repos:
\end_layout

\begin_layout Plain Layout

\size small
            owner = repo['owner']['login']
\end_layout

\begin_layout Plain Layout

\size small
            name = repo['name']
\end_layout

\begin_layout Plain Layout

\size small
            logger.debug('REPO: %s/%s' % (owner, name))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
            # get full data
\end_layout

\begin_layout Plain Layout

\size small
            # /repos/:owner/:repo
\end_layout

\begin_layout Plain Layout

\size small
            req_full_data = requests.get(
\end_layout

\begin_layout Plain Layout

\size small
                    'https://api.github.com/repos/%s/%s' % (owner, name),
\end_layout

\begin_layout Plain Layout

\size small
                     headers=HEADERS)
\end_layout

\begin_layout Plain Layout

\size small
            full_data = req_full_data.json()
\end_layout

\begin_layout Plain Layout

\size small
            rec = {'owner': owner, 'name': name}
\end_layout

\begin_layout Plain Layout

\size small
            for key in ['id', 'full_name', 'url', 'homepage', 'git_url',
\end_layout

\begin_layout Plain Layout

\size small
                    'stargazers_count', 'watchers_count', 'subscribers_count',
\end_layout

\begin_layout Plain Layout

\size small
                    'forks_count', 'size', 'fork', 'open_issues_count',
\end_layout

\begin_layout Plain Layout

\size small
                    'has_issues', 'has_wiki', 'has_downloads', 'pushed_at',
\end_layout

\begin_layout Plain Layout

\size small
                    'created_at', 'updated_at', 'network_count']:
\end_layout

\begin_layout Plain Layout

\size small
                rec[key] = full_data.get(key, '')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
            # NOTE: if there's never been a push, then forget it, jump
\end_layout

\begin_layout Plain Layout

\size small
            #       to the next repo
\end_layout

\begin_layout Plain Layout

\size small
            if rec['pushed_at'] is None:
\end_layout

\begin_layout Plain Layout

\size small
                logger.debug('EMPTY, move on')
\end_layout

\begin_layout Plain Layout

\size small
                continue
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
            parent_keys = ['id', 'fork', 'forks_count', 'stargazers_count',
\end_layout

\begin_layout Plain Layout

\size small
                    'watchers_count', 'open_issues_count']
\end_layout

\begin_layout Plain Layout

\size small
            wait_buffer(req_full_data)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
            # get contributors
\end_layout

\begin_layout Plain Layout

\size small
            # /repos/:owner/:repo/[stats/]contributors
\end_layout

\begin_layout Plain Layout

\size small
            # note: user stats/contributors because plain contributors 
\end_layout

\begin_layout Plain Layout

\size small
            #       paginates, even though it's a lot more data and can
 202
\end_layout

\begin_layout Plain Layout

\size small
            logger.debug('func: contributors')
\end_layout

\begin_layout Plain Layout

\size small
            r = requests.get('https://api.github.com/repos/%s/%s/contributors'
 %
\end_layout

\begin_layout Plain Layout

\size small
                    (owner, name), headers=HEADERS)
\end_layout

\begin_layout Plain Layout

\size small
            wait_buffer(r)
\end_layout

\begin_layout Plain Layout

\size small
            # secondary check for uninteresting repo
\end_layout

\begin_layout Plain Layout

\size small
            if r.status_code == 204:
\end_layout

\begin_layout Plain Layout

\size small
                logger.debug('204, move on')
\end_layout

\begin_layout Plain Layout

\size small
                continue
\end_layout

\begin_layout Plain Layout

\size small
            contributors = r.json()
\end_layout

\begin_layout Plain Layout

\size small
            while r.links.has_key('next'):
\end_layout

\begin_layout Plain Layout

\size small
                logger.debug('func: contributors')
\end_layout

\begin_layout Plain Layout

\size small
                r = requests.get(r.links['next']['url'], headers=HEADERS)
\end_layout

\begin_layout Plain Layout

\size small
                contributors.append(r.json())
\end_layout

\begin_layout Plain Layout

\size small
                wait_buffer(r)
\end_layout

\begin_layout Plain Layout

\size small
            rec['contributors'] = contributors
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
            # get participation
\end_layout

\begin_layout Plain Layout

\size small
            # /repos/:owner/:repo/stats/participation
\end_layout

\begin_layout Plain Layout

\size small
            participation = repo_api_request(owner, name, 'stats/participation')
\end_layout

\begin_layout Plain Layout

\size small
            if participation:
\end_layout

\begin_layout Plain Layout

\size small
                rec['participation'] = participation
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
            # get languages
\end_layout

\begin_layout Plain Layout

\size small
            # /repos/:owner/:repo/languages
\end_layout

\begin_layout Plain Layout

\size small
            languages = repo_api_request(owner, name, 'languages')
\end_layout

\begin_layout Plain Layout

\size small
            if languages:
\end_layout

\begin_layout Plain Layout

\size small
                rec['languages'] = languages
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
            # get code frequency
\end_layout

\begin_layout Plain Layout

\size small
            # /repos/:owner/:repo/stats/code_frequency
\end_layout

\begin_layout Plain Layout

\size small
            code_frequency = repo_api_request(owner, name,
\end_layout

\begin_layout Plain Layout

\size small
                    'stats/code_frequency')
\end_layout

\begin_layout Plain Layout

\size small
            if code_frequency:
\end_layout

\begin_layout Plain Layout

\size small
                rec['code_frequency'] = code_frequency
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
            # get teams
\end_layout

\begin_layout Plain Layout

\size small
            # /repos/:owner/:repo/teams
\end_layout

\begin_layout Plain Layout

\size small
            # NOTE: url pattern 404s across repos
\end_layout

\begin_layout Plain Layout

\size small
            #teams = repo_api_request(owner, name, 'teams')
\end_layout

\begin_layout Plain Layout

\size small
            #if teams:
\end_layout

\begin_layout Plain Layout

\size small
            #    rec['teams'] = teams
\end_layout

\begin_layout Plain Layout

\size small
            
\end_layout

\begin_layout Plain Layout

\size small
            # get hierarchy 
\end_layout

\begin_layout Plain Layout

\size small
            if full_data['fork']:
\end_layout

\begin_layout Plain Layout

\size small
                if full_data['parent']['id'] != full_data['id']:
\end_layout

\begin_layout Plain Layout

\size small
                    rec['parent'] = full_data['parent']
\end_layout

\begin_layout Plain Layout

\size small
                    for key in parent_keys:
\end_layout

\begin_layout Plain Layout

\size small
                        rec['parent_%s' % key] = rec['parent'].get(key, '')
\end_layout

\begin_layout Plain Layout

\size small
                if full_data['source']['id'] != full_data['parent']['id']:
\end_layout

\begin_layout Plain Layout

\size small
                    rec['source'] = full_data['source']
\end_layout

\begin_layout Plain Layout

\size small
                    for key in parent_keys:
\end_layout

\begin_layout Plain Layout

\size small
                        rec['source_%s' % key] = rec['source'].get(key, '')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
            recs.append(rec)
\end_layout

\begin_layout Plain Layout

\size small
            if len(recs) == 100:
\end_layout

\begin_layout Plain Layout

\size small
                save_recs(recs, count)
\end_layout

\begin_layout Plain Layout

\size small
                recs = []
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
            count += 1
\end_layout

\begin_layout Plain Layout

\size small
            logger.debug('count: %s' % count)
\end_layout

\begin_layout Plain Layout

\size small
            if count == FETCH_LIMIT:
\end_layout

\begin_layout Plain Layout

\size small
                break
\end_layout

\begin_layout Plain Layout

\size small
        logger.debug('FETCH: %s' % next_repos_url)
\end_layout

\begin_layout Plain Layout

\size small
        req_repos = requests.get(next_repos_url)
\end_layout

\begin_layout Plain Layout

\size small
        next_repos_url = next_url(req_repos.links['next']['url'])
\end_layout

\begin_layout Plain Layout

\size small
        repos = req_repos.json()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
if recs:
\end_layout

\begin_layout Plain Layout

\size small
    save_recs(recs, count)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_body
\end_document
